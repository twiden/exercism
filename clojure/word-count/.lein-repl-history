(if nil 1 2)
(if true 1 2)
(if "" 1 2)
(defn recursive-count [words]
    (loop [my-map {} my-words (seq words)]
        (if (my-words)
            (recur
                (assoc (first my-words) 1)
                (next my-words))
        my-map))
)
recursive-count []
(recursive-count [])
(recursive-count [""])
(recursive-count (""))
(if (= 1 1) 1, 2)
(defn my-zipmap [keys vals]
  (loop [my-map {}
         my-keys (seq keys)
         my-vals (seq vals)]
    (if (and my-keys my-vals)
      (recur (assoc my-map (first my-keys) (first my-vals))
             (next my-keys)
             (next my-vals))
      my-map)))
(my-zipmap [:a :b :c] [1 2 3])
(and [] [])
(and [1] [])
(and [1] [2])
(> 1 0)
sort()
sort([1, 3, 2])
sort([1 3 2])
(sort [1 3 2])
(sort "1 3 2")
(sort "132")
(update {} {})
(update {} [])
(update {} :a 1)
(update {:a 2} :a 1)
(update {2} :a 1)
(update-in {\A 2} [\A], (fn [x] 3))
(keys {\A 2})
(frequencies (s/split "GGGGCCAA" #""))
(:require [clojure.string :as s])
:require [clojure.string :as s
)
(:require [clojure.string :as s])
:require [clojure.string :as s]
(require 'clojure.string')
(require 'clojure.string)
(frequencies (string/split "GGGGCCAA" #""))
(frequencies (clojure/string/split "GGGGCCAA" #""))
(frequencies (clojure.string/split "GGGGCCAA" #""))
(update-in {\A 0, \T 0, \C 0, \G 0} [\A \T \C \G] (frequencies (clojure.string/split "GGGGCCAA" #"")))
(update-in {\A 0, \T 0, \C 0, \G 0} [\A \T \C \G] (frequencies (clojure.string/split (seq "GGGGCCAA") #"")))
(frequencies (clojure.string/split "GGGGCCAA" #""))
(frequencies (clojure.string/split (seq "GGGGCCAA") #""))
(frequencies (seq "GGGGCCAA"))
(update-in {\A 0, \T 0, \C 0, \G 0} [\A \T \C \G] (frequencies (seq "GGGGCCAA")))
(def dna "GCAAAACT")
println dna
(update-in {\A 0, \T 0, \C 0, \G 0} [\A \T \C \G] (frequencies (seq dna)))
(frequencies (seq dna))
(update-in {\A 0, \T 0, \C 0, \G 0} [\A \T \C \G] (frequencies (seq dna)))
(update {\A 0, \T 0, \C 0, \G 0}  (frequencies (seq dna)))
(sort (distinct (seq dna)))
(sort (keys {\A 0, \T 0, \C 0, \G 0}))
(count (filter (fn [x] ({\A 0, \T 0, \C 0, \G 0} x)) (seq dna)))
({\A 0, \T 0, \C 0, \G 0} x)
(distinct (seq "GGGGGGGG"))
(sort (distinct (seq "GGGGGGGG")))
(distinct (seq "GGGGGGGG"))
(def dna "GCAAAACT")
(map vector "123" "Abc")
(map vector "" "")
(map vector "123" "Abc")
((map vector "123" "Abc"))
(map (fn [x] x)(map vector "123" "Abc"))
(map (fn [x] (apply = x))(map vector "123" "Abc"))
(map (fn [x] (apply = x))(map vector "123" "A2c"))
(map (fn [x] ((apply = x)))(map vector "123" "A2c"))
(map (fn [x] (apply = x))(map vector "123" "A2c"))
(map (if (true))(map (fn [x] (apply = x))(map vector "123" "A2c"))))
(map (if (true)) (map (fn [x] (apply = x))(map vector "123" "A2c"))))
(map (if (true) 1 0) (map (fn [x] (apply = x))(map vector "123" "A2c"))))
(map '(if true 1 0) (map (fn [x] (apply = x))(map vector "123" "A2c"))))
(map (fn [x]  1 ) (map (fn [x] (apply = x))(map vector "123" "A2c"))))
(map (fn [x]  1 ) (map (fn [x] (apply = x))(map vector "123" "A2c")))
(map (fn [x] (apply = x))(map vector "123" "A2c"))
(map (fn [x] (if (apply = x) 1 0))(map vector "123" "A2c"))
(reduce + (map (fn [x] (if (apply = x) 1 0))(map vector "123" "A2c")))
(re-seq #"\d" "123m.[123")
(str (re-seq #"\d" "123m.[123"))
(apply str (re-seq #"\d" "123m.[123"))
(count "123")
(first "123")
(split-at 2 [1 2 3 4 5])
(split-at 2 "1234\5")
(split-at 2 "12345")
(split-at 3 "12345678901")
(apply str (split-at 3 "12345678901"))
(map str (split-at 3 "12345678901"))
(-> 0 1)
(-> 0 (1))
(-> {}(1))
(-> {}(1 2))
(-> {}(1 2 3))
(-> {}({1 2}))
(-> {}({1 2 3}))
(-> {}({1 2 3 4}))
(-> 0({1 2}))
(-> 0 (1))
(-> +) (1))
(-> +) (1)
(-> + (1))
(-> + #(1))
(-> + (fn 1))
(-> + (fn [x] 1))
(-> + (fn [x] 1) (fn [x] 2))
(-> 0 (fn [x] 1) (fn [x] 2))
(-> 0 (fn [x y] 1) (fn [x y] 2))
(-> 0 (+ 1 1) (+ 2 2))
